diff -purN a/primus_vk.cpp b/primus_vk.cpp
--- a/primus_vk.cpp	2018-10-13 09:05:45.000000000 +0300
+++ b/primus_vk.cpp	2018-10-13 15:57:40.828131298 +0300
@@ -256,7 +256,10 @@ public:
   VkFence fence;
   Fence(VkDevice dev): device(dev){
     // Create fence to ensure that the command buffer has finished executing
-    VkFenceCreateInfo fenceInfo = {.sType=VK_STRUCTURE_TYPE_FENCE_CREATE_INFO, .flags=0};
+    VkFenceCreateInfo fenceInfo;
+    fenceInfo.sType=VK_STRUCTURE_TYPE_FENCE_CREATE_INFO;
+    fenceInfo.pNext=nullptr;
+    fenceInfo.flags=0;
     VK_CHECK_RESULT(device_dispatch[GetKey(device)].CreateFence(device, &fenceInfo, nullptr, &fence));
   }
   void await(){
@@ -273,7 +276,10 @@ class Semaphore{
 public:
   VkSemaphore sem;
   Semaphore(VkDevice dev): device(dev){
-    VkSemaphoreCreateInfo semInfo = {.sType=VK_STRUCTURE_TYPE_SEMAPHORE_CREATE_INFO, .flags=0};
+    VkSemaphoreCreateInfo semInfo;
+    semInfo.sType=VK_STRUCTURE_TYPE_SEMAPHORE_CREATE_INFO;
+    semInfo.pNext=nullptr;
+    semInfo.flags=0;
     VK_CHECK_RESULT(device_dispatch[GetKey(device)].CreateSemaphore(device, &semInfo, nullptr, &sem));
   }
   ~Semaphore(){
@@ -444,13 +450,24 @@ class CommandBuffer {
 public:
   VkCommandBuffer cmd;
   CommandBuffer(VkDevice device) : device(device) {
-    VkCommandPoolCreateInfo poolInfo = {.sType = VK_STRUCTURE_TYPE_COMMAND_POOL_CREATE_INFO, .flags=VK_COMMAND_POOL_CREATE_RESET_COMMAND_BUFFER_BIT, .queueFamilyIndex = 0 };
+    VkCommandPoolCreateInfo poolInfo;
+    poolInfo.sType = VK_STRUCTURE_TYPE_COMMAND_POOL_CREATE_INFO;
+    poolInfo.pNext = nullptr;
+    poolInfo.flags=VK_COMMAND_POOL_CREATE_RESET_COMMAND_BUFFER_BIT;
+    poolInfo.queueFamilyIndex = 0;
     VK_CHECK_RESULT(device_dispatch[GetKey(device)].CreateCommandPool(device, &poolInfo, nullptr, &commandPool));
-    VkCommandBufferAllocateInfo cmdBufAllocateInfo = {.sType=VK_STRUCTURE_TYPE_COMMAND_BUFFER_ALLOCATE_INFO, .commandPool=commandPool, .level=VK_COMMAND_BUFFER_LEVEL_PRIMARY, .commandBufferCount = 1};
-
+    VkCommandBufferAllocateInfo cmdBufAllocateInfo;
+    cmdBufAllocateInfo.sType=VK_STRUCTURE_TYPE_COMMAND_BUFFER_ALLOCATE_INFO;
+    cmdBufAllocateInfo.pNext=nullptr;
+    cmdBufAllocateInfo.commandPool=commandPool;
+    cmdBufAllocateInfo.level=VK_COMMAND_BUFFER_LEVEL_PRIMARY;
+    cmdBufAllocateInfo.commandBufferCount = 1;
     VK_CHECK_RESULT(device_dispatch[GetKey(device)].AllocateCommandBuffers(device, &cmdBufAllocateInfo, &cmd));
-
-    VkCommandBufferBeginInfo cmdBufInfo = {.sType = VK_STRUCTURE_TYPE_COMMAND_BUFFER_BEGIN_INFO};
+    VkCommandBufferBeginInfo cmdBufInfo;
+    cmdBufInfo.sType = VK_STRUCTURE_TYPE_COMMAND_BUFFER_BEGIN_INFO;
+    cmdBufInfo.pNext = nullptr;
+    cmdBufInfo.flags = 0;
+    cmdBufInfo.pInheritanceInfo = nullptr;
     VK_CHECK_RESULT(device_dispatch[GetKey(device)].BeginCommandBuffer(cmd, &cmdBufInfo));
   }
   ~CommandBuffer(){
@@ -701,7 +718,7 @@ VK_LAYER_EXPORT VkResult VKAPI_CALL Prim
 }
 
 VK_LAYER_EXPORT void VKAPI_CALL PrimusVK_DestroySwapchainKHR(VkDevice device, VkSwapchainKHR swapchain, const VkAllocationCallbacks* pAllocator) {
-    if(swapchain == nullptr) { return;}
+    if(swapchain == 0) { return;}
   PrimusSwapchain *ch = reinterpret_cast<PrimusSwapchain*>(swapchain);
   TRACE(">> Destroy swapchain: " << (void*) ch->backend);
   // TODO: the Nvidia driver segfaults when passing a chain here?
@@ -738,7 +755,7 @@ VK_LAYER_EXPORT VkResult VKAPI_CALL Prim
   {
     Fence myfence{ch->display_device};
 
-    res = device_dispatch[GetKey(ch->display_device)].AcquireNextImageKHR(ch->display_device, ch->backend, timeout, nullptr, myfence.fence, pImageIndex);
+    res = device_dispatch[GetKey(ch->display_device)].AcquireNextImageKHR(ch->display_device, ch->backend, timeout, 0, myfence.fence, pImageIndex);
     TRACE_PROFILING_EVENT(*pImageIndex, "got image");
 
     myfence.await();
@@ -747,7 +764,7 @@ VK_LAYER_EXPORT VkResult VKAPI_CALL Prim
   qsi.sType = VK_STRUCTURE_TYPE_SUBMIT_INFO;
   qsi.signalSemaphoreCount = 1;
   qsi.pSignalSemaphores = &semaphore;
-  device_dispatch[GetKey(ch->render_queue)].QueueSubmit(ch->render_queue, 1, &qsi, nullptr);
+  device_dispatch[GetKey(ch->render_queue)].QueueSubmit(ch->render_queue, 1, &qsi, 0);
   TRACE_PROFILING_EVENT(*pImageIndex, "Acquire done");
 
   return res;
@@ -921,7 +938,7 @@ void PrimusSwapchain::copyImageData(uint
   }
   {
     std::unique_lock<std::mutex> lock(queueMutex);
-    display_commands[index]->submit(display_queue, nullptr, sems);
+    display_commands[index]->submit(display_queue, 0, sems);
   }
 }
 
